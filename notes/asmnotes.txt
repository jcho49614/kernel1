**************************************
NOTES FOR ASSEMBLY BASIC INSTRUCTIONS
**************************************

-------------------------------------------------------------

Registers (in order of 32/16/8 if applicable):

eax/ax/al: general purpose, accumulator for math, syscalls
ebx/bx/bl: general purpose, base pointer for memory
ecx/cx/cl: loop counter (mov ecx, 5 runs loop 5 times), general purpose
edx/dx/dl: I/O operations, general purpose
esi/si: source index (strings, memory optimizations)
edi/di: destination index
esp, sp: stack pointers (used for the one stack in assembly code)
ebp, bp: base pointer for stack frames

-------------------------------------------------------------

Moving instructions:

Basic moving works in the following structure/format:
mov (recipient), (wanted_value).


For example, if we want to put the immediate integer "5" into eax, we would do:
mov eax, 5.

stored memory into register:
mov eax, [0x1000]

register values into newfound memory:
mov [0x1000], eax

if size is ambiguous, we will use:
byte: for 1 byte operations
word: for 2 byte operations
dword: for 4 byte operations
qword: for 8 byte operations

-------------------------------------------------------------

Arithmetic operations (mostly done in eax):
add eax, 1      eax = eax+1
sub eax, 1      eax = eax-1
imul eax, 1     eax = eax * 1 (signed operations)
xor eax, eax    excluded or. returns 1 if different, 0 if same, eax = 0.
and eax, 0xFF   masking lower byte
or eax, 0x100   set bits in register.

-------------------------------------------------------------

Stack operations:
There is only one stack in the entire program. we initialize/allocate the stack values through:
stack_space resb 0x____ (in our case, 0x1000 reserves 4kb for stack)

Stacks operate on a LIFO (last in, first out) system. We can only "stack" (push) a value
on the top of the stack, and only take out (pop) the top value of the stack.

Every single time we stack something, the amount of memory available in the stack, stored in 
esp, reduces. assume that esp is currently 0x8000.

mov eax, 5      ;moves 5 to eax --> 4 bit signed integer
push eax        ;eax is now in the a

the output of esp will now be 0x7FFC, 4 bytes taken away.
the following function 

pop eax

will not only put the stored top value of the stack into eax (in our case, 5),
but also will return esp back to 0x8000, our intial allocated amount.

this code:

mov eax, 42
add eax, 3      ; eax = 45
push eax        ; push value of eax onto stack
xor eax, eax    ; clear eax
pop eax         ; pop value back into eax
; eax = 45 again

will

1. put the value of 42 into eax,
2. add 3 to eax making it 45,
3. push eax into the stack
4. intiialize eax (0)
5. pop 45, back into eax.

-------------------------------------------------------------

Control flow - Flags

A flag can be represented as a "status" symbol. The most current process that affects flags,
will in effect change the "eflags" register to the current process. the various flags are:
(stars set for important ones)

CF: Carry Flag (unsigned integer arithmetic overflow during add, sub) *
PF: Parity Flag (least significant byte has even number of 1 bits)
AF: Auxilary Flag (set if carry from lower nibble)
ZF: Zero Flag (if resut is zero, used during compare, sub, etc) *
SF: Sign Flag (if result is negative: sign bit is 0 or 1) *
TF: Trap Flag (debugging)
IF: Interrupt Flag (disables/enables hardware interrupts) 
DF: direction flag (controls strings operations) 
OF: Overflow flag (see if signed arithmetic overflow occurs, CF but signed) *

-------------------------------------------------------------

Control Flow - Jumps and Conditionals

Jumps are equivalent to "continue"s and "goto"s. if we set a function as jmp <label>,
the code will always jump to label. Jumps can be conditional, too, such as:

je/jz: zero flag = 1
jne/jnz: zero flag = 0

jl(if less)/jnge(not greater or equal): jump if less (signed)
jle(if less or equal)/jng(nt greater): jump if less or equal (signed)
jg(greater)/jnle(not less or equal): jump if greater (signed)
jge(greater than or equal)/jnl(not less): jump if greater of equal (signed)

jb (if below)/jc (if carry): jump if below (unsigned)
jbe (if below or equal)/jna (not above): jump if below or equal (unsigned)
ja (if above)/jnbe (not below or equal): jump if above (unsigned)
jae (if above or equal)/jnb (not below): jump if above or equal (unsign

and so many more.

Flags can be elicited through these following functions:

(arithmetic)
add: add – adds two values, sets CF, OF, SF, ZF, AF, PF – used for signed and unsigned addition
adc: add with carry – adds two values + CF, sets CF, OF, SF, ZF, AF, PF – used for multi-precision addition
sub: subtract – subtracts second operand from first, sets CF, OF, SF, ZF, AF, PF – used for signed and unsigned subtraction
sbb: subtract with borrow – subtracts second operand + CF, sets CF, OF, SF, ZF, AF, PF – used for multi-precision subtraction
inc: increment – adds 1 to operand, sets OF, SF, ZF, AF, PF – does not affect CF
dec: decrement – subtracts 1 from operand, sets OF, SF, ZF, AF, PF – does not affect CF
mul: multiply – multiplies operand(s), sets CF, OF – unsigned multiplication overflow
imul: signed multiply – multiplies operand(s), sets CF, OF – signed multiplication overflow
div: divide – divides, affects flags indirectly (CPU exceptions on divide by zero/overflow)
idiv: signed divide – divides signed numbers, affects flags indirectly

(logical/bitwise)
and: bitwise AND – performs AND on operands, sets SF, ZF, PF – clears CF and OF
or: bitwise OR – performs OR on operands, sets SF, ZF, PF – clears CF and OF
xor: bitwise XOR – performs XOR on operands, sets SF, ZF, PF – clears CF and OF; common for zeroing registers
not: bitwise NOT – inverts bits, does not affect flags
shl: shift left – shifts bits left, sets CF, OF, SF, ZF, PF – used for multiplication by powers of 2
shr: shift right – shifts bits right, sets CF, OF, SF, ZF, PF – logical shift (unsigned)
sar: arithmetic shift right – shifts bits right preserving sign, sets CF, OF, SF, ZF, PF – signed shift
rol: rotate left – rotates bits left through CF, sets CF, OF
ror: rotate right – rotates bits right through CF, sets CF, OF
rcl: rotate through carry left – rotates bits + CF, sets CF, OF
rcr: rotate through carry right – rotates bits + CF, sets CF, OF

(compare and test)
cmp: compare – subtracts second operand from first, sets CF, OF, SF, ZF, AF, PF – does not change operands; used for conditional jumps
test: test – bitwise AND of operands, sets SF, ZF, PF – does not change operands; used for checking bits

(strings)
scasb/scasw/scasd: scan string – compares accumulator with memory, sets SF, ZF, CF – used in loops/arrays
cmpsb/cmpsw/cmpsd: compare string – compares memory operands, sets SF, ZF, CF – used for string comparison

(control/flag specifc instructions)
lahf: load AH from flags – stores SF, ZF, AF, PF, CF into AH – allows reading flags in C
sahf: store AH into flags – loads SF, ZF, AF, PF, CF from AH – allows restoring flags
pushf: push flags – pushes EFLAGS onto stack – useful to save flags
popf: pop flags – pops EFLAGS from stack – restores flags
stc: set carry flag – sets CF=1 – used for arithmetic or multi-precision
clc: clear carry flag – sets CF=0 – used for arithmetic or multi-precision
cmc: complement carry – inverts CF – used for arithmetic or multi-precision
cld: clear direction flag – sets DF=0 – string operations auto-increment
std: set direction flag – sets DF=1 – string operations auto-decrement
cli: clear interrupt flag – disables hardware interrupts
sti: set interrupt flag – enables hardware interrupts

and much much more.

-------------------------------------------------------------

Control Flow - Loops

with ecx as the primary loop counter, each loop subtracts ecx once and essentially keeps running
until ecx runs out.

Example:

mov ecx, 5
start_loop:
    ;do something
    loop start_loop     ;the use of the word "loop" leads to decrease of ecx.

ecx = 0 leads to the stop of the loop.

There are many forms of the loop:
loop: decrement ecx, jump if ecx != 0 – basic counted loop; always jumps until ecx reaches 0
loope (loop while equal)/loopz (loop while zero): decrement ecx, jump if ecx != 0 and ZF = 1 – loops while last comparison was equal
loopne (loop while not equal)/loopnz (loop while not zero): decrement ecx, jump if ecx != 0 and ZF = 0 – loops while last comparison was not equal

-------------------------------------------------------------

